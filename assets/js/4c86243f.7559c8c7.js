"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[9807],{3905:function(e,t,r){r.r(t),r.d(t,{MDXContext:function(){return s},MDXProvider:function(){return m},mdx:function(){return h},useMDXComponents:function(){return u},withMDXComponents:function(){return p}});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},i.apply(this,arguments)}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),p=function(e){return function(t){var r=u(t.components);return n.createElement(e,i({},t,{components:r}))}},u=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):c(c({},t),e)),r},m=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),p=u(r),m=a,f=p["".concat(o,".").concat(m)]||p[m]||d[m]||i;return r?n.createElement(f,c(c({ref:t},s),{},{components:r})):n.createElement(f,c({ref:t},s))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=f;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var s=2;s<i;s++)o[s]=r[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},49421:function(e,t,r){r.r(t),r.d(t,{contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return c},metadata:function(){return s},toc:function(){return p}});var n=r(87462),a=r(63366),i=(r(67294),r(3905)),o=["components"],c={id:"ttl_reaper",title:"TTL Reaper"},l=void 0,s={unversionedId:"Cache_Library_User_Guides/ttl_reaper",id:"Cache_Library_User_Guides/ttl_reaper",isDocsHomePage:!1,title:"TTL Reaper",description:"Cachelib allocators support time to live (TTL) on an item natively at the granularity of seconds. When you set a TTL on an item, the item is automatically reaped if it is still present in the cache after its expiry.  The find() method returns an empty handle (nullptr) for an item that has expired.",source:"@site/docs/Cache_Library_User_Guides/ttl_reaper.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/ttl_reaper",permalink:"/docs/Cache_Library_User_Guides/ttl_reaper",editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/ttl_reaper.md",tags:[],version:"current",frontMatter:{id:"ttl_reaper",title:"TTL Reaper"},sidebar:"userguideSidebar",previous:{title:"Cross Host Cache Persistence",permalink:"/docs/Cache_Library_User_Guides/Cross_Host_Cache_Persistence"},next:{title:"Oom protection",permalink:"/docs/Cache_Library_User_Guides/oom_protection"}},p=[{value:"Configure reaper",id:"configure-reaper",children:[]}],u={toc:p};function m(e){var t=e.components,r=(0,a.Z)(e,o);return(0,i.mdx)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Cachelib allocators support time to live (TTL) on an item natively at the granularity of seconds. When you set a TTL on an item, the item is automatically reaped if it is still present in the cache after its expiry.  The ",(0,i.mdx)("inlineCode",{parentName:"p"},"find()")," method returns an empty handle (",(0,i.mdx)("inlineCode",{parentName:"p"},"nullptr"),") for an item that has expired."),(0,i.mdx)("p",null,"For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-cpp"},'uint32_t ttlSecs = 600;   // expires in 10 mins\nauto item =  cache.allocate(poolId, "hello-world", size, ttlSecs);\ncache.insertOrReplace(item);\n\n// Try to find the item after 10 mins.\nauto item = cache.find("hello-world");  // returns nullptr\n')),(0,i.mdx)("p",null,"Note that setting a TTL on an item ",(0,i.mdx)("em",{parentName:"p"},"does not guarantee that the item lives for the TTL"),", but rather makes the item stale and not accessible if it is still present in the cache beyond the TTL."),(0,i.mdx)("h2",{id:"configure-reaper"},"Configure reaper"),(0,i.mdx)("p",null,"The reaper is responsible for reclaiming the memory from expired items. Reaper is enabled by default. The speed at which reaper runs can be controlled in the following way."),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"reaperIntervalSecs"),"  Configures the interval at which reaper scans the cache to reclaim the memory for expired items. Recommend setting this to ",(0,i.mdx)("inlineCode",{parentName:"li"},"10 seconds"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"reaperConfig")," This provides a more fine grained throttling on the reaper if you want to control the CPU variance of the reaper.")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-cpp"},"config.enableItemReaperInBackground(\n  std::chrono::milliseconds interval,\n  util::Throttler::Config reaperConfig = {}\n);\n")),(0,i.mdx)("p",null,"Call the ",(0,i.mdx)("inlineCode",{parentName:"p"},"getReaperStats()")," method to access the reaper statistics, which provides a a breakdown of the number of items visited against the reaped count."))}m.isMDXComponent=!0}}]);
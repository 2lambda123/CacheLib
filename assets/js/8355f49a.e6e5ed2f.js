"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[2153],{3905:function(e,t,n){n.r(t),n.d(t,{MDXContext:function(){return m},MDXProvider:function(){return u},mdx:function(){return f},useMDXComponents:function(){return d},withMDXComponents:function(){return s}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},o.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var m=a.createContext({}),s=function(e){return function(t){var n=d(t.components);return a.createElement(e,o({},t,{components:n}))}},d=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(m.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),s=d(n),u=r,p=s["".concat(i,".").concat(u)]||s[u]||h[u]||o;return n?a.createElement(p,c(c({ref:t},m),{},{components:n})):a.createElement(p,c({ref:t},m))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var m=2;m<o;m++)i[m]=n[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},60027:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return c},metadata:function(){return m},toc:function(){return d}});var a=n(83117),r=n(80102),o=(n(67294),n(3905)),i=["components"],c={id:"Remove_callback",title:"Remove callback"},l=void 0,m={unversionedId:"Cache_Library_User_Guides/Remove_callback",id:"Cache_Library_User_Guides/Remove_callback",title:"Remove callback",description:"Use Item Destructor whenever is possible, contact us if it",source:"@site/docs/Cache_Library_User_Guides/Remove_callback.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/Remove_callback",permalink:"/docs/Cache_Library_User_Guides/Remove_callback",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/Remove_callback.md",tags:[],version:"current",frontMatter:{id:"Remove_callback",title:"Remove callback"},sidebar:"userguideSidebar",previous:{title:"Item Destructor",permalink:"/docs/Cache_Library_User_Guides/Item_Destructor"},next:{title:"Cache persistence",permalink:"/docs/Cache_Library_User_Guides/Cache_persistence"}},s={},d=[{value:"RemoveCBData",id:"removecbdata",level:2},{value:"Guarantees",id:"guarantees",level:2},{value:"NvmCache",id:"nvmcache",level:2}],u={toc:d};function h(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.mdx)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Use ",(0,o.mdx)("a",{parentName:"p",href:"Item_Destructor"},"Item Destructor")," whenever is possible, contact us if it\ndoesn't satisfy your requirement and RemoveCallback has to be used."),(0,o.mdx)("p",null,(0,o.mdx)("em",{parentName:"p"},"Remove callback")," provides destructor semantics for an item in the cache. This is useful when you want to execute some logic on removal of an item from the cache. When you use cachelib APIs to concurrently allocate memory from the cache for an item, insert an item into the cache, or remove an item from the cache, the item's lifetime ends when the item is evicted or removed from the cache and the last handle held by all sources drops. ",(0,o.mdx)("em",{parentName:"p"},"Remove callback")," provides you an ability to capture this and take some appropriate action if needed."),(0,o.mdx)("p",null,"For example, suppose you want to maintain a counter for the total number of items in your cache and increment the counter when you call the ",(0,o.mdx)("inlineCode",{parentName:"p"},"insertOrReplace()")," method. The item you inserted could be evicted or removed from the cache when you again call ",(0,o.mdx)("inlineCode",{parentName:"p"},"insertOrReplace()")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"allocate()"),". To decrement the counter when the item you inserted is evicted or removed by another thread, you can have your logic encapsulated as ",(0,o.mdx)("em",{parentName:"p"},"remove callback"),"."),(0,o.mdx)("p",null,(0,o.mdx)("em",{parentName:"p"},"Remove callback")," takes the following signature and can be provided in the config for initializing the cache:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},"auto removeCB = [&](const Allocator::RemoveCbData& data) { --totalItems; };\nconfig.setRemoveCallback(removeCB);\n\n// Adds an item to cache and increment the counter.\nvoid addToCache(std::string key, size_t val) {\n  auto handle = cache.allocate(keys[i], 100); // allocate an item\n  cache.insertOrReplace(handle); // insert into cache.\n  ++totalItems;\n}\n\n// Suppose your cache can contain at most 5 items and\n// it evicts beyond that.\nfor (int i = 0; i < 1000; i++) {\n  addToCache(std::to_string(i), 100);\n}\n\nstd::cout << totalItems << std::endl; // this will print 5.\n")),(0,o.mdx)("h2",{id:"removecbdata"},"RemoveCBData"),(0,o.mdx)("p",null,(0,o.mdx)("em",{parentName:"p"},"Remove callback")," gets called with the following pieces of information:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},"// Holds information about removal, used in RemoveCb\nstruct RemoveCbData {\n  // Remove or eviction\n  RemoveContext context;\n\n  // Item about to be freed back to allocator\n  Item& item;\n\n  // Iterator range pointing to chained allocs associated with items\n  folly::Range<ChainedItemIter> chainedAllocs;\n};\n")),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"context")," This refers to the context of removal. ",(0,o.mdx)("inlineCode",{parentName:"li"},"RemoveCB")," can be called ","[invoked]"," on an item when it is explicitly removed by the user through the ",(0,o.mdx)("inlineCode",{parentName:"li"},"remove()")," API or when it is replacing an old item through the ",(0,o.mdx)("inlineCode",{parentName:"li"},"insertOrReplace()")," API, or when it being evicted to make room for a new item. For the first two calls on ",(0,o.mdx)("inlineCode",{parentName:"li"},"RemoveCB"),", the context is ",(0,o.mdx)("inlineCode",{parentName:"li"},"kRemoval"),"; and for eviction, the context is ",(0,o.mdx)("inlineCode",{parentName:"li"},"kEviction"),"."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"item")," Reference to the item that is being destroyed. Modifying the item at this point is pointless because this is the last handle to the item and the memory will be recycled after the call to the remove callback."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"chainedAllocs")," This provides a reference to the list of chained items associated with the given item if they exist. For details on what chained allocations are, see ",(0,o.mdx)("a",{parentName:"li",href:"Visit_data_in_cache"},"visit data in cache"),".")),(0,o.mdx)("h2",{id:"guarantees"},"Guarantees"),(0,o.mdx)("p",null,"Cachelib guarantees the following for remove callback executions:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The callback will be executed ",(0,o.mdx)("em",{parentName:"li"},"exactly once")," when the last handle for the item goes out of scope and the item is no longer accessible through the cache upon calling ",(0,o.mdx)("inlineCode",{parentName:"li"},"remove()")," or ",(0,o.mdx)("inlineCode",{parentName:"li"},"insertOrReplace()")," causing a replace."),(0,o.mdx)("li",{parentName:"ul"},"The callback will be executed for any item that is evicted from cache."),(0,o.mdx)("li",{parentName:"ul"},"When the callback is executed, there can be no other future or concurrent accessors to the item."),(0,o.mdx)("li",{parentName:"ul"},"The callback will ",(0,o.mdx)("em",{parentName:"li"},"not")," be executed if you allocate memory for an item and don't insert the item into the cache."),(0,o.mdx)("li",{parentName:"ul"},"The callback will ",(0,o.mdx)("em",{parentName:"li"},"not")," be executed when items are moved internally.")),(0,o.mdx)("p",null,"Note that remove callback is executed per item, not per key. For example, if you already have an item in cache and call ",(0,o.mdx)("inlineCode",{parentName:"p"},"insertOrReplace()")," to replace it with another item with same key, cachelib will execute remove callback for the replaced item."),(0,o.mdx)("h2",{id:"nvmcache"},"NvmCache"),(0,o.mdx)("p",null,"Currently remove callback is not supported seamlessly when NvmCache is enabled. This will be addressed and available in the near future."))}h.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[4703],{3905:function(e,n,t){t.r(n),t.d(n,{MDXContext:function(){return c},MDXProvider:function(){return p},mdx:function(){return h},useMDXComponents:function(){return m},withMDXComponents:function(){return u}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},i.apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),u=function(e){return function(n){var t=m(n.components);return r.createElement(e,i({},n,{components:t}))}},m=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=m(e.components);return r.createElement(c.Provider,{value:n},e.children)},f={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=m(t),p=a,d=u["".concat(o,".").concat(p)]||u[p]||f[p]||i;return t?r.createElement(d,l(l({ref:n},c),{},{components:t})):r.createElement(d,l({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=t[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},83747:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return m}});var r=t(83117),a=t(80102),i=(t(67294),t(3905)),o=["components"],l={id:"WSA_overview",title:"Working Set Analysis Overview"},s=void 0,c={unversionedId:"facebook/Working_Set_Analysis/WSA_overview",id:"facebook/Working_Set_Analysis/WSA_overview",title:"Working Set Analysis Overview",description:"POCs",source:"@site/docs/facebook/Working_Set_Analysis/WSA_overview.md",sourceDirName:"facebook/Working_Set_Analysis",slug:"/facebook/Working_Set_Analysis/WSA_overview",permalink:"/docs/facebook/Working_Set_Analysis/WSA_overview",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/facebook/Working_Set_Analysis/WSA_overview.md",tags:[],version:"current",frontMatter:{id:"WSA_overview",title:"Working Set Analysis Overview"}},u={},m=[{value:"POCs",id:"pocs",level:3},{value:"Links",id:"links",level:3},{value:"Overview",id:"overview",level:3},{value:"Analysis",id:"analysis",level:3},{value:"UI",id:"ui",level:3}],p={toc:m};function f(e){var n=e.components,t=(0,a.Z)(e,o);return(0,i.mdx)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h3",{id:"pocs"},"POCs"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Pietari Pulkkinen (Infrastructure Data Science)"),(0,i.mdx)("li",{parentName:"ul"},"Hengli Liang (Infrastructure Data Science)"),(0,i.mdx)("li",{parentName:"ul"},"Sathya Gunasekar (Cachelib)"),(0,i.mdx)("li",{parentName:"ul"},"Jimmy Lu (Cachelib)"),(0,i.mdx)("li",{parentName:"ul"},"Hao Wu (Cachelib)"),(0,i.mdx)("li",{parentName:"ul"},"Eden Zik (Memcache)"),(0,i.mdx)("li",{parentName:"ul"},"Zifan Yang (Memcache)")),(0,i.mdx)("h3",{id:"links"},"Links"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"https://www.internalfb.com/cachelib/wsa/"},"Working Set Analysis UI")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"https://fb.workplace.com/groups/452627415509944"},"Workplace group"))),(0,i.mdx)("h3",{id:"overview"},"Overview"),(0,i.mdx)("p",null,"Working Set Analysis (WSA) is a collaborative project between CacheLib, Memcache, and Infra Data Science which aims to provide tools for analyzing and understanding cache workload patterns to improve cache performance. WSA itself is an umbrella term which encompasses a variety of offline analyses & models. At its core, the WSA project is an ",(0,i.mdx)("strong",{parentName:"p"},"offline traffic analysis framework")," with an easy configurator-based opt-in for cache owners who are interested in optimizing their caches."),(0,i.mdx)("p",null,"Working Set Analysis is not a cache simulation project. The insights derived from WSA are insights about the traffic that a cache must serve. WSA aims to help you optimize your cache to meet the demands of your traffic."),(0,i.mdx)("p",null,'For information about caches, working sets, "traffic", etc. please see ',(0,i.mdx)("a",{parentName:"p",href:"WSA_helpful_definitions"},"Helpful Definitions"),"."),(0,i.mdx)("h3",{id:"analysis"},"Analysis"),(0,i.mdx)("p",null,'More information on the following analyses can be found in the "Analysis and Optimizations" section.'),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Working set monitoring (including set intersection and overlap)"),(0,i.mdx)("li",{parentName:"ul"},"Hit rate vs. cache size estimates for LRU-like caches"),(0,i.mdx)("li",{parentName:"ul"},"Object churn and future value models, which encompasses",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"Tuning time-to-access evictions"),(0,i.mdx)("li",{parentName:"ul"},"Flash admission models"))),(0,i.mdx)("li",{parentName:"ul"},"Traffic partitioning analyses e.g. Arena assignment and sizing for TAO")),(0,i.mdx)("h3",{id:"ui"},"UI"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("a",{parentName:"p",href:"https://www.internalfb.com/cachelib/wsa"},"Working Set Analysis UI is a self-service")," way to monitor your use case(s). We currently show metrics for ",(0,i.mdx)("a",{parentName:"p",href:"https://www.internalfb.com/intern/wiki/Cache_Library_User_Guides/Analyses_and_Optimizations/#hit-rate-analyses-guaran"},"our multi-tenant cache analysis"),". Features include:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Filters for Date, Granularity, Server and separate regex filters for each granularity selected that control everything on the page"),(0,i.mdx)("li",{parentName:"ul"},"A chart for Cache Size vs Hit Rate"),(0,i.mdx)("li",{parentName:"ul"},'An accompanying table with additional information. Users can change the "Lifetime in seconds" option to view the data for a given lifetime (e.g. 60 seconds) in the table'),(0,i.mdx)("li",{parentName:"ul"},'To make the relationship between data in the table and the chart clear, hovering over a row in the table highlights the corresponding point on the chart (also based off the selected "Lifetime in seconds")')),(0,i.mdx)("p",null,"You can also go to the UI easily via bunnylol ",(0,i.mdx)("inlineCode",{parentName:"p"},"wsa {myusecase}")))}f.isMDXComponent=!0}}]);
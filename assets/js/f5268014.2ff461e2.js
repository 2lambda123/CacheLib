"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[4055],{3905:function(e,t,a){a.r(t),a.d(t,{MDXContext:function(){return s},MDXProvider:function(){return p},mdx:function(){return b},useMDXComponents:function(){return m},withMDXComponents:function(){return d}});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},r.apply(this,arguments)}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),d=function(e){return function(t){var a=m(t.components);return n.createElement(e,r({},t,{components:a}))}},m=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=m(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),d=m(a),p=i,h=d["".concat(l,".").concat(p)]||d[p]||u[p]||r;return a?n.createElement(h,o(o({ref:t},s),{},{components:a})):n.createElement(h,o({ref:t},s))}));function b(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=a[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},27863:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return c},default:function(){return u},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return m}});var n=a(83117),i=a(80102),r=(a(67294),a(3905)),l=["components"],o={id:"Object_Cache_User_Guide",title:"CacheLib Object Cache User Guide"},c=void 0,s={unversionedId:"facebook/Object_Cache/Object_Cache_User_Guide",id:"facebook/Object_Cache/Object_Cache_User_Guide",title:"CacheLib Object Cache User Guide",description:"Object-Cache enables users to cache C++ objects natively in CacheLib.",source:"@site/docs/facebook/Object_Cache/object_cache_user_guide.md",sourceDirName:"facebook/Object_Cache",slug:"/facebook/Object_Cache/Object_Cache_User_Guide",permalink:"/docs/facebook/Object_Cache/Object_Cache_User_Guide",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/facebook/Object_Cache/object_cache_user_guide.md",tags:[],version:"current",frontMatter:{id:"Object_Cache_User_Guide",title:"CacheLib Object Cache User Guide"}},d={},m=[{value:"Set up object-cache",id:"set-up-object-cache",level:2},{value:"Create a simple object-cache",id:"create-a-simple-object-cache",level:3},{value:"Configuration",id:"configuration",level:4},{value:"Create a &quot;size-aware&quot; object-cache",id:"create-a-size-aware-object-cache",level:3},{value:"Configuration",id:"configuration-1",level:4},{value:"How to calculate object size",id:"how-to-calculate-object-size",level:4},{value:"How is object size tracked",id:"how-is-object-size-tracked",level:4},{value:"What is size controller",id:"what-is-size-controller",level:4},{value:"Add monitoring",id:"add-monitoring",level:3},{value:"Use object-cache",id:"use-object-cache",level:2},{value:"Add objects",id:"add-objects",level:3},{value:"Get objects",id:"get-objects",level:3},{value:"Remove objects",id:"remove-objects",level:3},{value:"TTL (Time To Live)",id:"ttl-time-to-live",level:2},{value:"Set TTL",id:"set-ttl",level:3},{value:"Get TTL",id:"get-ttl",level:3},{value:"Update TTL",id:"update-ttl",level:3},{value:"Cache Persistence",id:"cache-persistence",level:2},{value:"Configure cache persistence",id:"configure-cache-persistence",level:3},{value:"Use cache persistence",id:"use-cache-persistence",level:3}],p={toc:m};function u(e){var t=e.components,a=(0,i.Z)(e,l);return(0,r.mdx)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"Object-Cache enables users to cache C++ objects natively in CacheLib."),(0,r.mdx)("p",null,"Not sure whether you should use object-cache? Check the ",(0,r.mdx)("a",{parentName:"p",href:"Object_Cache_Decision_Guide"},"object-cache decision guide"),"."),(0,r.mdx)("h2",{id:"set-up-object-cache"},"Set up object-cache"),(0,r.mdx)("h3",{id:"create-a-simple-object-cache"},"Create a simple object-cache"),(0,r.mdx)("p",null,"The simplest object-cache is limited by the ",(0,r.mdx)("strong",{parentName:"p"},"number of objects"),", i.e. an eviction will be triggered when the total object number reaches certain limit; the limit needs to be configured by the user as ",(0,r.mdx)("inlineCode",{parentName:"p"},"l1EntriesLimit"),"."),(0,r.mdx)("p",null,"If your system is able to track the number of objects and provide that limit, you are good to use this option. If not, you may need to ",(0,r.mdx)("a",{parentName:"p",href:"#create-a-size-aware-object-cache"},'create a "size-aware" object-cache'),"."),(0,r.mdx)("h4",{id:"configuration"},"Configuration"),(0,r.mdx)("p",null,"You can set up a simple object-cache by configuring the following settings in ",(0,r.mdx)("inlineCode",{parentName:"p"},"ObjectCacheConfig"),":"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"l1EntriesLimit"),": The object number limit for object-cache to hold. Above this many entries, object-cache will start evicting."),(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"cacheName"),": The name of the cache."),(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"itemDestructor"),": The callback that will be triggered when the object leaves the cache. Users must set this to explicitly delete the objects; otherwise, there will be memory leak.")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"// store a single type of objects\nconfig.setItemDestructor(\n      [&](ObjectCacheDestructorData data) {\n        data.deleteObject<Foo>();\n});\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"// store multiple types of objects\n// One way is to encode the type in the key.\nenum class user_defined_ObjectType { Foo1, Foo2, Foo3 };\n\nconfig.setItemDestructor([&](ObjectCacheDestructorData data) {\n     switch (user_defined_getType(data.key)) {\n       case user_defined_ObjectType::Foo1:\n         data.deleteObject<Foo1>();\n         break;\n       case user_defined_ObjectType::Foo2:\n         data.deleteObject<Foo2>();\n         break;\n       case user_defined_ObjectType::Foo3:\n         data.deleteObject<Foo3>();\n         break;\n       ...\n     }\n });\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Suggested"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"maxKeySizeBytes"),": The maximum size of the key to be inserted. It cannot exceed 255 bytes. Default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"255"),". Since we also use this size to decide the size of object-cache, we suggest you set a reasonble value to avoid wasting space."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"l1HashTablePower"),": This controls how many buckets are present in object-cache's hashtable. Default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"10"),". Check out ",(0,r.mdx)("a",{parentName:"li",href:"../../Cache_Library_User_Guides/Configure_HashTable"},"hashtable bucket configuration")," to select a good value."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"l1LockPower"),": This controls how many locks are present in object-cache's hashtable. Default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"10"),"."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"l1NumShards"),": Number of shards to improve insert/remove concurrency. Default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"1"),"."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"l1ShardName"),": Name of the shards. If not set, we will use the default name ",(0,r.mdx)("inlineCode",{parentName:"li"},"pool"),".")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/experimental/objcache2/ObjectCache.h"\n\nusing ObjectCache = cachelib::objcache2::ObjectCache<cachelib::LruAllocator>;\nstd::unique_ptr<ObjectCache> objCache;\n\nstruct Foo {\n ...\n};\n\nvoid init() {\n    ObjectCache::Config config;\n    config.setCacheName("SimpleObjectCache")\n        .setCacheCapacity(10\'000 /* l1EntriesLimit */)\n        .setItemDestructor(\n            [&](cachelib::objcache2::ObjectCacheDestructorData data) {\n              data.deleteObject<Foo>();\n            })\n        .setMaxKeySizeBytes(8)\n        .setAccessConfig(15 /* l1hashTablePower */, 10 /* l1locksPower */)\n        .setNumShards(2) /* optional */\n        .setShardName("my_shard") /* optional */;\n\n    objCache = ObjectCache::create(std::move(config));\n}\n\n')),(0,r.mdx)("h3",{id:"create-a-size-aware-object-cache"},'Create a "size-aware" object-cache'),(0,r.mdx)("p",null,'If your system needs to cap the cache size by bytes where the simple version mentioned above is not good enough, you can enable the "size-awareness" feature.'),(0,r.mdx)("p",null,'A "size-aware" object-cache tracks the object size internally and is limited by the ',(0,r.mdx)("strong",{parentName:"p"},"total size of objects"),", i.e. an eviction will be triggered when the total size of objects reaches certain limit; the limit needs to be configured by the user as ",(0,r.mdx)("inlineCode",{parentName:"p"},"cacheSizeLimit"),"."),(0,r.mdx)("p",null,"\u2757 ",(0,r.mdx)("strong",{parentName:"p"},"IMPORTANT:"),' A few notes before you try to create a "size-aware" object-cache:'),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"This feature currently only works for ",(0,r.mdx)("strong",{parentName:"li"},"immutable")," access.",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},'Immutable access means no "in-place modification" of the object once inserted to the cache.'),(0,r.mdx)("li",{parentName:"ul"},"In the future, we might be able to support ",(0,r.mdx)("strong",{parentName:"li"},"mutable")," access."))),(0,r.mdx)("li",{parentName:"ul"},"Objects number is still bounded by ",(0,r.mdx)("inlineCode",{parentName:"li"},"l1EntriesLimit"),".",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Above this many entries, object-cache will start evicting even if ",(0,r.mdx)("inlineCode",{parentName:"li"},"cacheSizeLimit")," has not been reached."),(0,r.mdx)("li",{parentName:"ul"},"Make sure you set a reasonably large ",(0,r.mdx)("inlineCode",{parentName:"li"},"l1EntriesLimit")," to avoid objects early eviction when it's far from reaching ",(0,r.mdx)("inlineCode",{parentName:"li"},"cacheSizeLimit"),"."))),(0,r.mdx)("li",{parentName:"ul"},"Users are responsible to calculate the size of each object and pass the value to object-cache:",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"We provide a util class to help calculate the object size. Check out ",(0,r.mdx)("a",{parentName:"li",href:"#how-to-calculate-object-size"},'"how to calculate object size"'),"."),(0,r.mdx)("li",{parentName:"ul"},"Object-cache maintains the total object size internally based on the object size provided by users. See more in ",(0,r.mdx)("a",{parentName:"li",href:"#how-is-object-size-tracked"},'"how is object size tracked"'),".")))),(0,r.mdx)("h4",{id:"configuration-1"},"Configuration"),(0,r.mdx)("p",null,"To set up a ",(0,r.mdx)("strong",{parentName:"p"},"size-aware")," object-cache, besides the ",(0,r.mdx)("a",{parentName:"p",href:"#configuration"},"settings")," mentioned above, also configure the following settings:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"sizeControllerIntervalMs"),": Set a non-zero period (in milliseconds) to enable the ",(0,r.mdx)("a",{parentName:"li",href:"#what-is-size-controller"},'"size-controller"'),". ",(0,r.mdx)("inlineCode",{parentName:"li"},"0"),' means "size-controller" is disabled.'),(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"cacheSizeLimit"),": The limit of cache size in bytes. If total object size is above this limit, object-cache will start evicting.")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/experimental/objcache2/ObjectCache.h"\n\nusing ObjectCache = cachelib::objcache2::ObjectCache<cachelib::LruAllocator>;\nstd::unique_ptr<ObjectCache> objCacheSizeAware;\n\nstruct Foo {\n ...\n};\n\nvoid init() {\n    ObjectCache::Config config;\n    config.setCacheName("SizeAwareObjectCache")\n          .setCacheCapacity(10\'000 /* l1EntriesLimit*/,\n                            30 * 1024 * 1024 * 1024 /* 30GB, cacheSizeLimit */,\n                            100 /* sizeControllerIntervalMs */)\n          .setItemDestructor(\n            [&](cachelib::objcache2::ObjectCacheDestructorData data) {\n              data.deleteObject<Foo>();\n            })\n          .setMaxKeySizeBytes(8)\n          .setAccessConfig(15 /* l1hashTablePower */, 10 /* l1locksPower */)\n          .setNumShards(2) /* optional */\n          .setShardName("my_shard") /* optional */;\n\n    objCacheSizeAware = ObjectCache::create(std::move(config));\n}\n\n')),(0,r.mdx)("h4",{id:"how-to-calculate-object-size"},"How to calculate object size"),(0,r.mdx)("p",null,"It is users' responsibility to calculate each object size (i.e. how many bytes are occupied by the object). We provide a util class ",(0,r.mdx)("inlineCode",{parentName:"p"},"ThreadMemoryTracker")," that users can leverage to do the calculation."),(0,r.mdx)("p",null,"The basic idea is:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},"Use Jemalloc util function (",(0,r.mdx)("inlineCode",{parentName:"li"},"thread.allocated")," and ",(0,r.mdx)("inlineCode",{parentName:"li"},"thread.deallocated"),") to calculate allocated memory and deallocated memory in the current thread:")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"  memory usage = allocate memory - deallocated memory\n")),(0,r.mdx)("ol",{start:2},(0,r.mdx)("li",{parentName:"ol"},"Get the currently used memory before and after the object construction, the difference is the object memory:")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"   get before memory usage\n   ...construct object\n   get after memory usage\n   object size = after memory usage - before memory usage\n")),(0,r.mdx)("p",null,"Example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/experimental/objcache2/util/ThreadMemoryTracker.h"\n\n// initialize memory tracker only at the beginning\ncachelib::objcache2::ThreadMemoryTracker tMemTracker;\n...\n\nauto beforeMemUsage = tMemTracker.getMemUsageBytes();\n...construct the object\nauto afterMemUsage = tMemTracker.getMemUsageBytes();\n// afterMemUsage < beforeMemUsage occurs very rarely when the current thread\n// spawns children threads and the main thread deallocate memory allocated by\n// the children thread.\nauto objectSize = LIKELY(afterMemUsage > beforeMemUsage)\n                        ? (afterMemUsage - beforeMemUsage)\n                        : 0;\n')),(0,r.mdx)("h4",{id:"how-is-object-size-tracked"},"How is object size tracked"),(0,r.mdx)("p",null,"When an object is inserted to the cache via ",(0,r.mdx)("inlineCode",{parentName:"p"},"insertOrReplace")," / ",(0,r.mdx)("inlineCode",{parentName:"p"},"insert"),' API, users must pass "object size" to the API.'),(0,r.mdx)("p",null,"After that, object-cache knows the size for each cached object and maintains the total object size internally."),(0,r.mdx)("h4",{id:"what-is-size-controller"},"What is size controller"),(0,r.mdx)("p",null,'Size-controller is the key component to achieve a "size-aware" object-cache. It is a periodic background worker that dynamically adjusts the ',(0,r.mdx)("strong",{parentName:"p"},"entries limit")," by monitoring the current ",(0,r.mdx)("strong",{parentName:"p"},"total object size")," and ",(0,r.mdx)("strong",{parentName:"p"},"total object number"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"averageObjectSize = totalObjectSize / totalObjectNum\n\nnewEntriesLimit = config.cacheSizeLimit / averageObjectSize\n")),(0,r.mdx)("p",null,"In this case, we can guarantee cache size does not exceed ",(0,r.mdx)("inlineCode",{parentName:"p"},"cacheSizeLimit")," from long-term perspective. However, as it is not a precise control, we cannot prevent a sudden increase in object sizes."),(0,r.mdx)("h3",{id:"add-monitoring"},"Add monitoring"),(0,r.mdx)("p",null,"After the initialization, you should also add ",(0,r.mdx)("a",{parentName:"p",href:"../Cache_Monitoring/Cache_Admin_Overview"},"cacheAdmin")," to enable ",(0,r.mdx)("a",{parentName:"p",href:"../Cache_Monitoring/monitoring"},"monitoring")," for object-cache."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/facebook/admin/CacheAdmin.h"\n\nstd::unique_ptr<cachelib::CacheAdmin> cacheAdmin;\n\nvoid init() {\n  ... setting up the object-cache here\n\n  CacheAdmin::Config adminConfig; // default config should work just fine\n  adminConfig.oncall = "my_team_oncall_shortname";\n  cacheAdmin = std::make_unique<CacheAdmin>(*objCache, adminConfig);\n}\n')),(0,r.mdx)("h2",{id:"use-object-cache"},"Use object-cache"),(0,r.mdx)("h3",{id:"add-objects"},"Add objects"),(0,r.mdx)("p",null,"To add objects to object-cache, call ",(0,r.mdx)("inlineCode",{parentName:"p"},"insertOrReplace")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"insert")," API:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\nstd::tuple<bool, std::shared_ptr<T>, std::shared_ptr<T>> insertOrReplace(\n    folly::StringPiece key,\n    std::unique_ptr<T> object,\n    size_t objectSize = 0,\n    uint32_t ttlSecs = 0);\n\ntemplate <typename T>\nstd::pair<AllocStatus, std::shared_ptr<T>> insert(folly::StringPiece key,\n                                                  std::unique_ptr<T> object,\n                                                  size_t objectSize = 0,\n                                                  uint32_t ttlSecs = 0);\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"insertOrReplace"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Insert an object into the cache with a given key."),(0,r.mdx)("li",{parentName:"ul"},"If the key exists in the cache, it will be replaced with new object."),(0,r.mdx)("li",{parentName:"ul"},"Return a tuple of allocation status (",(0,r.mdx)("inlineCode",{parentName:"li"},"kSuccess")," or ",(0,r.mdx)("inlineCode",{parentName:"li"},"kAllocError"),") , ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," of newly inserted object (even if the object is not successfully inserted, it will still be converted to a ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," and returned), and ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," of the old object that has been replaced (if no replacement happened, ",(0,r.mdx)("inlineCode",{parentName:"li"},"nullptr")," will be returned)."))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"insert"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Unique insert an object into the cache with a given key."),(0,r.mdx)("li",{parentName:"ul"},"If the key exists in the cache, the new object will NOT be inserted."),(0,r.mdx)("li",{parentName:"ul"},"Return a pair of allocation status (",(0,r.mdx)("inlineCode",{parentName:"li"},"kSuccess"),", ",(0,r.mdx)("inlineCode",{parentName:"li"},"kKeyAlreadyExists")," or ",(0,r.mdx)("inlineCode",{parentName:"li"},"kAllocError"),") and ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," of newly inserted object. Note that even if the object is not successfully inserted, it will still be converted to a ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," and returned.")))),(0,r.mdx)("p",null,"Parameters:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"key"),": object key"),(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"object"),": ",(0,r.mdx)("inlineCode",{parentName:"li"},"unique_ptr")," of the object to be inserted"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"objectSize"),": size of the object to be inserted",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"0")),(0,r.mdx)("li",{parentName:"ul"},"for non-size-aware ones, always leave the value as ",(0,r.mdx)("inlineCode",{parentName:"li"},"0")),(0,r.mdx)("li",{parentName:"ul"},"for size-aware ones, ",(0,r.mdx)("strong",{parentName:"li"},"MUST provide a non-zero value")," (check out ",(0,r.mdx)("a",{parentName:"li",href:"#how-to-calculate-object-size"},'"how to calculate object size"'),")"))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"ttlSecs"),": Time To Live(seconds) for the object",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"0")," means object has no expiring time.")))),(0,r.mdx)("p",null,"Example(non-size-aware):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"...\nauto [allocStatus, ptr, oldPtr] =\n    objcache->insertOrReplace(key,\n                              std::move(foo),\n                              0 /*objectSize tracking is not enabled*/,\n                              ttlSecs /*optional*/);\nif (allocStatus == ObjectCache::AllocStatus::kSuccess) {\n  ...\n  return ptr;\n} else { // ObjectCache::AllocStatus::kAllocError\n  ...\n}\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"...\nauto [allocStatus, ptr] =\n    objcache->insert(key,\n                     std::move(foo),\n                     0 /*objectSize tracking is not enabled*/,\n                     ttlSecs /*optional*/);\nif (allocStatus == ObjectCache::AllocStatus::kSuccess) {\n  ...\n  return ptr;\n} else if (allocStatus == ObjectCache::AllocStatus::kKeyAlreadyExists) {\n  ...\n} else { // ObjectCache::AllocStatus::kAllocError\n  ...\n}\n")),(0,r.mdx)("p",null,"Example(size-aware):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"...\nauto [allocStatus, ptr, oldPtr] =\n    objcacheSizeAware->insertOrReplace(key,\n                                       std::move(foo),\n                                       objectSize /* must be non-zero */,\n                                       ttlSecs /*optional*/);\nif (allocStatus == ObjectCache::AllocStatus::kSuccess) {\n  ...\n  return ptr;\n} else { // ObjectCache::AllocStatus::kAllocError\n  ...\n}\n...\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"...\nauto [allocStatus, ptr] =\n    objcacheSizeAware->insert(key,\n                              std::move(foo),\n                              objectSize /* must be non-zero*/,\n                              ttlSecs /*optional*/);\nif (allocStatus == ObjectCache::AllocStatus::kSuccess) {\n  ...\n  return ptr;\n} else if (allocStatus == ObjectCache::AllocStatus::kKeyAlreadyExists) {\n  ...\n} else { // ObjectCache::AllocStatus::kAllocError\n  ...\n}\n...\n")),(0,r.mdx)("h3",{id:"get-objects"},"Get objects"),(0,r.mdx)("p",null,"To get objects from object-cache, call ",(0,r.mdx)("inlineCode",{parentName:"p"},"find")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"findToWrite")," API:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\nstd::shared_ptr<const T> find(folly::StringPiece key);\n\ntemplate <typename T>\nstd::shared_ptr<T> findToWrite(folly::StringPiece key);\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"find"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Look up an object in ",(0,r.mdx)("strong",{parentName:"li"},"read-only")," access."),(0,r.mdx)("li",{parentName:"ul"},"Return a ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," to a const version of the object if found; ",(0,r.mdx)("inlineCode",{parentName:"li"},"nullptr")," if not found."))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"findToWrite"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Look up an object in ",(0,r.mdx)("strong",{parentName:"li"},"mutable")," access."),(0,r.mdx)("li",{parentName:"ul"},"Return a ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," to a mutable version of the object if found; ",(0,r.mdx)("inlineCode",{parentName:"li"},"nullptr")," if not found.")))),(0,r.mdx)("p",null,"\u2757 ",(0,r.mdx)("strong",{parentName:"p"},"IMPORTANT:")),(0,r.mdx)("p",null,"Separating write and read traffic is quite important here. A misuse of these two APIs can lead to unreasonable eviction result because we only promotes read traffic by default. For more details, check out ",(0,r.mdx)("a",{parentName:"p",href:"/docs/Cache_Library_User_Guides/eviction_policy#configuration"},'"Eviction policy"')),(0,r.mdx)("p",null,"The guidance here is:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Always consider ",(0,r.mdx)("inlineCode",{parentName:"li"},"find")," API first;"),(0,r.mdx)("li",{parentName:"ul"},"Choose ",(0,r.mdx)("inlineCode",{parentName:"li"},"findToWrite")," API only when an in-place modification needs to happen.")),(0,r.mdx)("p",null,"Example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'std::shared_ptr<const Foo> foo = objcache->find<Foo>("foo");\nif (foo !== nullptr) {\n    ... some read operation\n}\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'std::shared_ptr<Foo> mutableFoo = objcache->findToWrite<Foo>("foo");\nif (mutableFoo !== nullptr) {\n    ... some write operation\n}\n\n')),(0,r.mdx)("h3",{id:"remove-objects"},"Remove objects"),(0,r.mdx)("p",null,"To remove objects from object-cache, call ",(0,r.mdx)("inlineCode",{parentName:"p"},"remove")," API:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"bool remove(folly::StringPiece key);\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"remove"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Remove an object from cache by its key. No-op if the key not found."),(0,r.mdx)("li",{parentName:"ul"},"Return ",(0,r.mdx)("inlineCode",{parentName:"li"},"false")," if the key is not found in object-cache.")))),(0,r.mdx)("p",null,"Example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'// objcache is empty\nobjcache->remove<Foo>("foo"); // no-op, return `false`\n\nobjcache->insertOrReplace<Foo>("foo", std::move(foo));\n...\n\nobjcache->remove<Foo>("foo"); // foo will be removed, return `true`\n')),(0,r.mdx)("h2",{id:"ttl-time-to-live"},"TTL (Time To Live)"),(0,r.mdx)("p",null,"Object-Cache provides the same TTL support as in regular cacheLib."),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"TTL is at the granularity of seconds"),(0,r.mdx)("li",{parentName:"ul"},"Object will not be accessible if it is beyond the TTL (i.e. ",(0,r.mdx)("inlineCode",{parentName:"li"},"find")," API will return ",(0,r.mdx)("inlineCode",{parentName:"li"},"nullptr"),")"),(0,r.mdx)("li",{parentName:"ul"},"Object could still exist in the cache if it is beyond the TTL. We use ",(0,r.mdx)("inlineCode",{parentName:"li"},"Reaper")," (cachelib's TTL worker) to periodically remove expired objects from the cache. By default, the Reaper runs every 5 seconds. Users can also set a different interval via ",(0,r.mdx)("inlineCode",{parentName:"li"},"ObjectCacheConfig"),":")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"ObjectCache::Config config;\n...\nconfig.setItemReaperInterval(std::chrono::milliseconds{10000}) // reaper will run every 10 seconds;\n")),(0,r.mdx)("h3",{id:"set-ttl"},"Set TTL"),(0,r.mdx)("p",null,"As what mentioned in ",(0,r.mdx)("a",{parentName:"p",href:"#add-objects"},'"Add objects"')," section, set the ttl for an object upon insertion:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"objcache->insertOrReplace(key,\n                          std::move(obj),\n                          objectSize,\n                          10 /* ttl is 10 seconds */);\n\nobjcache->insert(key,\n                 std::move(obj),\n                 objectSize,\n                 10 /* ttl is 10 seconds */);\n")),(0,r.mdx)("h3",{id:"get-ttl"},"Get TTL"),(0,r.mdx)("p",null,"To get a cached object's ttl, we provide ",(0,r.mdx)("inlineCode",{parentName:"p"},"getExpiryTimeSec")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"getConfiguredTtl")," APIs:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\nuint32_t getExpiryTimeSec(const std::shared_ptr<T>& object) const;\n\ntemplate <typename T>\nstd::chrono::seconds getConfiguredTtl(const std::shared_ptr<T>& object) const;\n\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"getExpiryTimeSec"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Return the expiry timestamp of the passed object (in seconds)"))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"getConfiguredTtl"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Return the configured TTL of the passed object (in seconds)")))),(0,r.mdx)("p",null,"\u2757 ",(0,r.mdx)("strong",{parentName:"p"},"IMPORTANT:")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"The passed object shared pointer must be fetched from object-cache APIs (e.g. find, insert APIs).")),(0,r.mdx)("p",null,"Usage 1:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'auto obj = objcache->find<T>("key");\nauto expiryTimeSec = objcache->getExpiryTimeSec(obj);\nif (expiryTime != 0) { // ttl is set\n    if (expiryTimeSec < util::getCurrentTimeSec()) { // not expired\n        ...\n    } else {\n        ...\n    }\n}\n')),(0,r.mdx)("p",null,"Usage 2:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'auto obj = objcache->find<T>("key");\nauto ttlSecs = objcache->getConfiguredTtl(obj).count();\nif (ttlSecs != 0) { // ttl is set\n    ...\n}\n')),(0,r.mdx)("p",null,"Object's ",(0,r.mdx)("inlineCode",{parentName:"p"},"expiryTime")," is also accessible via ",(0,r.mdx)("inlineCode",{parentName:"p"},"ObjectCacheDestructorData"),". One usage could be checking whether the object is expired when it's leaving the cache:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"ObjectCache::Config config;\n...\nconfig.setItemDestructor(\n       [&](cachelib::objcache2::ObjectCacheDestructorData data) {\n  ...\n  if (data.expiryTime >= util::getCurrentTimeSec()) { // expired\n     ...\n  }\n  ...\n  data.deleteObject<T>();\n}\n")),(0,r.mdx)("h3",{id:"update-ttl"},"Update TTL"),(0,r.mdx)("p",null,"To update a cached object's ttl, we provide ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateExpiryTimeSec")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"extendTtl")," APIs:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\nbool updateExpiryTimeSec(std::shared_ptr<T>& object,\n                         uint32_t newExpiryTimeSecs);\n\ntemplate <typename T>\nbool extendTtl(std::shared_ptr<T>& object, std::chrono::seconds ttl);\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"updateExpiryTimeSec"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Update the expiry timestamp to ",(0,r.mdx)("inlineCode",{parentName:"li"},"newExpiryTimeSecs")),(0,r.mdx)("li",{parentName:"ul"},"Return ",(0,r.mdx)("inlineCode",{parentName:"li"},"true")," if the expiry time was successfully updated"))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"extendTtl"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Extend the expiry timestamp to ",(0,r.mdx)("inlineCode",{parentName:"li"},"now + ttl")," (in seconds)"),(0,r.mdx)("li",{parentName:"ul"},"Return ",(0,r.mdx)("inlineCode",{parentName:"li"},"true")," if the expiry time was successfully extended")))),(0,r.mdx)("p",null,"\u2757 ",(0,r.mdx)("strong",{parentName:"p"},"IMPORTANT:")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"The passed object shared pointer must be fetched from object-cache APIs (e.g. find, insert APIs).")),(0,r.mdx)("p",null,"Usage 1:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'auto obj = objcache->findToWrite<T>("key"); // calling find() API is also fine\nobjcache->updateExpiryTimeSec(obj, util::getCurrentTimeSec() + 300 /* 5mins */); // expiryTime becomes now + 5mins\n...\n')),(0,r.mdx)("p",null,"Usage 2:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'auto obj = objcache->findToWrite<T>("key"); // calling find() API is also fine\nobjcache->extendTtl(obj, std::chrono::seconds(300) /* 5 mins*/); // expiryTime becomes now + 5mins\n...\n')),(0,r.mdx)("h2",{id:"cache-persistence"},"Cache Persistence"),(0,r.mdx)("p",null,"Cache persistence is an opt-in feature in object-cache to persist objects across process restarts. It is useful when you want to restart your binary without losing previously cached objects. Currently we support cache persistence in a multi-thread mode where user can configure the parallelism degree to adjust the persistence/recovery speed."),(0,r.mdx)("p",null,"Before enabling cache persistence, please be aware of the following limitations:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Only works when you restart the process in the same machine. Across machines persistence is not supported."),(0,r.mdx)("li",{parentName:"ul"},"Only Thrift objects can be persisted.")),(0,r.mdx)("p",null,"To enable cache persistence, you need to configure the following parameters:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"threadCount"),": number of threads to work on persistence/recovery concurrently"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"persistBasefilePath"),": file path to save the persistent data",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},'cache metadata will be saved in "persistBasefilePath";'),(0,r.mdx)("li",{parentName:"ul"},'objects will be saved in "persistBasefilePath_i", i in [0, threadCount)'))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"serializeCallback"),": callback to serialize an object, used for object persisting",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"it takes ",(0,r.mdx)("inlineCode",{parentName:"li"},"ObjectCache::Serializer")," which has a ",(0,r.mdx)("inlineCode",{parentName:"li"},"serialize<T>()")," API that serializes the object of type ",(0,r.mdx)("inlineCode",{parentName:"li"},"T")," and returns a ",(0,r.mdx)("inlineCode",{parentName:"li"},"folly::IOBuf"),"."))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"deserializeCallback"),": callback to deserialize an object, used for object recovery",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"it takes ",(0,r.mdx)("inlineCode",{parentName:"li"},"ObjectCache::Deserializer")," which has a ",(0,r.mdx)("inlineCode",{parentName:"li"},"deserialize<T>()")," API that deserializes the object of type ",(0,r.mdx)("inlineCode",{parentName:"li"},"T")," and inserts it to the cache; returns ",(0,r.mdx)("inlineCode",{parentName:"li"},"true")," when the insertion is successful.")))),(0,r.mdx)("h3",{id:"configure-cache-persistence"},"Configure cache persistence"),(0,r.mdx)("p",null,"Example (single-type):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"ObjectCache::Config config;\n...\nconfig.enablePersistence(threadCount,\n                         persistBaseFilePath,\n                           [&](ObjectCache::Serializer serializer) {\n                             return serializer.serialize<ThriftType>();\n                           },\n                          [&](ObjectCache::Deserializer deserializer) {\n                             return deserializer.deserialize<ThriftType>();\n                           });\n\n\n")),(0,r.mdx)("p",null,"Example (multi-type):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"ObjectCache::Config config;\n...\nconfig.enablePersistence(threadCount,\n                         persistBaseFilePath,\n                           [&](ObjectCache::Serializer serializer) {\n                   switch (user_defined_getType(serializer.key)) {\n                         case user_defined_Type::ThriftType1:\n                              return serializer.serialize<ThriftType1>();\n                         case user_defined_Type::ThriftType2:\n                              return serializer.serialize<ThriftType2>();\n                         case user_defined_Type::ThriftType3:\n                              return serializer.serialize<ThriftType3>();\n                         default:\n                              \u2026\n                           },\n                          [&](ObjectCache::Deserializer deserializer) {\n                     switch (user_defined_getType(serializer.key)) {\n                         case user_defined_Type::ThriftType1:\n                              return deserializer.deserialize<ThriftType1>();\n                         case user_defined_Type::ThriftType2:\n                              return deserializer.deserialize<ThriftType2>();\n                         case user_defined_Type::ThriftType3:\n                              return deserializer.deserialize<ThriftType3>();\n                         default:\n                              \u2026\n                           });\n\n")),(0,r.mdx)("h3",{id:"use-cache-persistence"},"Use cache persistence"),(0,r.mdx)("p",null,"Once cache persistence is enabled, to persist or recover objects, it is as simple as an API call."),(0,r.mdx)("p",null,"To persist, user should call ",(0,r.mdx)("inlineCode",{parentName:"p"},"persist()")," API upon cache shutdown:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"objCache->persist(); // all non-expired objects will be saved to files\n")),(0,r.mdx)("p",null,"To recover, user should call ",(0,r.mdx)("inlineCode",{parentName:"p"},"recover()")," API upon cache restart:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"objCache->recover(); // all saved non-expired objects will be recovered\n")),(0,r.mdx)("p",null,"Notes:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Expired objects won't be persisted or recovered."),(0,r.mdx)("li",{parentName:"ul"},"To correctly recover objects, user must put the same ",(0,r.mdx)("inlineCode",{parentName:"li"},"persistBaseFilePath")," as the previous persistent cache instance."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"threadCount")," is for persisting parallelism of the current cache instance. Recovery will always use the same ",(0,r.mdx)("inlineCode",{parentName:"li"},"threadCount")," as the previous persistent cache instance. For example:")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'config1.enablePersistence(5 /*threadCount*/, "baseFile_1", ..., ...);\nauto objCache1 = ObjectCache::create(config1);\n...\n// ... shutting down cache\nobjCache1.persist(); // threadCount = 5\n\n...\nconfig2.enablePersistence(10 /*threadCount*/, "baseFile_1", ..., ...);\nauto objCache2 = ObjectCache::create(config2);\n//... restarting cache\nobjCache2.recover(); // threadCount = 5\n...\n//... shutting down cache\nobjCache2.persist(); // threadCount = 10\n\n')))}u.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[4055],{3905:function(e,t,n){n.r(t),n.d(t,{MDXContext:function(){return d},MDXProvider:function(){return u},mdx:function(){return b},useMDXComponents:function(){return m},withMDXComponents:function(){return s}});var c=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(){return a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var c in n)Object.prototype.hasOwnProperty.call(n,c)&&(e[c]=n[c])}return e},a.apply(this,arguments)}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);t&&(c=c.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,c)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,c,o=function(e,t){if(null==e)return{};var n,c,o={},a=Object.keys(e);for(c=0;c<a.length;c++)n=a[c],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(c=0;c<a.length;c++)n=a[c],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=c.createContext({}),s=function(e){return function(t){var n=m(t.components);return c.createElement(e,a({},t,{components:n}))}},m=function(e){var t=c.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=m(e.components);return c.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return c.createElement(c.Fragment,{},t)}},h=c.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,r=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),s=m(n),u=o,h=s["".concat(r,".").concat(u)]||s[u]||p[u]||a;return n?c.createElement(h,i(i({ref:t},d),{},{components:n})):c.createElement(h,i({ref:t},d))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,r[1]=i;for(var d=2;d<a;d++)r[d]=n[d];return c.createElement.apply(null,r)}return c.createElement.apply(null,n)}h.displayName="MDXCreateElement"},27863:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return i},metadata:function(){return d},toc:function(){return s}});var c=n(87462),o=n(63366),a=(n(67294),n(3905)),r=["components"],i={id:"Object_Cache_User_Guide",title:"CacheLib Object Cache User Guide"},l=void 0,d={unversionedId:"facebook/Object_Cache/Object_Cache_User_Guide",id:"facebook/Object_Cache/Object_Cache_User_Guide",isDocsHomePage:!1,title:"CacheLib Object Cache User Guide",description:"Object-Cache enables users to cache C++ objects natively in CacheLib.",source:"@site/docs/facebook/Object_Cache/object_cache_user_guide.md",sourceDirName:"facebook/Object_Cache",slug:"/facebook/Object_Cache/Object_Cache_User_Guide",permalink:"/docs/facebook/Object_Cache/Object_Cache_User_Guide",editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/facebook/Object_Cache/object_cache_user_guide.md",tags:[],version:"current",frontMatter:{id:"Object_Cache_User_Guide",title:"CacheLib Object Cache User Guide"}},s=[{value:"Set up object-cache",id:"set-up-object-cache",children:[{value:"Create a simple object-cache",id:"create-a-simple-object-cache",children:[]},{value:"Add monitoring",id:"add-monitoring",children:[]}]},{value:"Use object-cache",id:"use-object-cache",children:[{value:"Add objects",id:"add-objects",children:[]},{value:"Get objects",id:"get-objects",children:[]},{value:"Remove objects",id:"remove-objects",children:[]}]}],m={toc:s};function u(e){var t=e.components,n=(0,o.Z)(e,r);return(0,a.mdx)("wrapper",(0,c.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"Object-Cache enables users to cache C++ objects natively in CacheLib."),(0,a.mdx)("p",null,"Not sure whether you should use object-cache? Check the ",(0,a.mdx)("a",{parentName:"p",href:"Object_Cache_Decision_Guide"},"object-cache decision guide"),"."),(0,a.mdx)("h2",{id:"set-up-object-cache"},"Set up object-cache"),(0,a.mdx)("h3",{id:"create-a-simple-object-cache"},"Create a simple object-cache"),(0,a.mdx)("p",null,"You can set up object-cache by configuring the following settings in ",(0,a.mdx)("inlineCode",{parentName:"p"},"ObjectCacheConfig"),":"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"(",(0,a.mdx)("strong",{parentName:"li"},"Required"),") ",(0,a.mdx)("inlineCode",{parentName:"li"},"l1EntriesLimit"),": Above this many entries, object-cache will start evicting. The object-cache size is also estimated based on this number."),(0,a.mdx)("li",{parentName:"ul"},"(",(0,a.mdx)("strong",{parentName:"li"},"Required"),") ",(0,a.mdx)("inlineCode",{parentName:"li"},"cacheName"),": The name of the cache."),(0,a.mdx)("li",{parentName:"ul"},"(",(0,a.mdx)("strong",{parentName:"li"},"Required"),") ",(0,a.mdx)("inlineCode",{parentName:"li"},"maxKeySizeBytes"),": The maximum sizeof key to be inserted. It cannot exceed 255 bytes."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("inlineCode",{parentName:"li"},"l1HashTablePower"),": This controls how many buckets are present in object-cache's hashtable. Default to ",(0,a.mdx)("inlineCode",{parentName:"li"},"10"),"."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("inlineCode",{parentName:"li"},"l1LockPower"),": This controls how many locks are present in object-cache's hashtable. Default to ",(0,a.mdx)("inlineCode",{parentName:"li"},"10"),"."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("inlineCode",{parentName:"li"},"l1NumShards"),": Number of shards to improve insert/remove concurrency. Default to ",(0,a.mdx)("inlineCode",{parentName:"li"},"1"),".")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/experimental/objcache2/ObjectCache.h"\n\nusing ObjectCache = cachelib::objcache2::ObjectCache<cachelib::LruAllocator>;\nstd::unique_ptr<ObjectCache> objCache;\n\nstruct Foo {\n ...\n};\n\nvoid init() {\n    cachelib::objcache2::ObjectCacheConfig config;\n    config.l1EntriesLimit = 10\'000;\n    config.maxKeySizeBytes = 8;\n    config.cacheName = "MyObjectCache";\n\n    objCache = ObjectCache::create<Foo>(std::move(config));\n}\n\n')),(0,a.mdx)("h3",{id:"add-monitoring"},"Add monitoring"),(0,a.mdx)("p",null,"After the initialization, you should also add ",(0,a.mdx)("a",{parentName:"p",href:"../Cache_Monitoring/Cache_Admin_Overview"},"cacheAdmin")," to enable ",(0,a.mdx)("a",{parentName:"p",href:"../Cache_Monitoring/monitoring"},"monitoring")," for object-cache."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/facebook/admin/CacheAdmin.h"\n\nstd::unique_ptr<cachelib::CacheAdmin> cacheAdmin;\n\nvoid init() {\n  ... setting up the object-cache here\n\n  CacheAdmin::Config adminConfig; // default config should work just fine\n  adminConfig.oncall = "my_team_oncall_shortname";\n  cacheAdmin = std::make_unique<CacheAdmin>(*objCache, adminConfig);\n}\n')),(0,a.mdx)("h2",{id:"use-object-cache"},"Use object-cache"),(0,a.mdx)("h3",{id:"add-objects"},"Add objects"),(0,a.mdx)("p",null,"To add objects to object-cache, call ",(0,a.mdx)("inlineCode",{parentName:"p"},"insertOrReplace")," or ",(0,a.mdx)("inlineCode",{parentName:"p"},"insert")," API:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-cpp"},"// Insert the object into the cache with given key. If the key exists in the\n// cache, it will be replaced with new obejct.\n//\n// Returns a pair of allocation status and shared_ptr of newly inserted object.\ntemplate <typename T>\nstd::pair<bool, std::shared_ptr<T>> insertOrReplace(\n    folly::StringPiece key,\n    std::unique_ptr<T> object, /* object to be inserted */\n    uint32_t ttlSecs = 0, /* object expiring seconds */\n    std::shared_ptr<T>* replacedPtr = nullptr /* object to be replaced if not nullptr */ );\n\n// Insert the object into the cache with given key. If the key exists in the\n// cache, the new object won't be inserted.\n//\n// Returns a pair of allocation status and shared_ptr of newly inserted object.\n// Even if object is not inserted, it will still be converted to a shared_ptr and returned.\ntemplate <typename T>\nstd::pair<AllocStatus, std::shared_ptr<T>> insert(folly::StringPiece key,\n                                                  std::unique_ptr<T> object,\n                                                  uint32_t ttlSecs = 0);\n\n")),(0,a.mdx)("p",null,"Example:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-cpp"},"std::shared_ptr<Foo> cacheFoo(folly::StringPiece key, std::unique_ptr<Foo> foo) {\n    ...\n    auto [allocStatus, ptr] = objcache->insertOrReplace(key, std::move(foo));\n    if (allocStatus == ObjectCache::AllocStatus::kSuccess) {\n         ...\n         return ptr;\n    } else { // ObjectCache::AllocStatus::kAllocError\n        ...\n    }\n    ...\n}\n\nstd::shared_ptr<Foo> cacheFooUnique(folly::StringPiece key, std::unique_ptr<Foo> foo) {\n    ...\n    auto [allocStatus, ptr] = objcache->insert(key, std::move(foo));\n    if (allocStatus == ObjectCache::AllocStatus::kSuccess) {\n         ...\n         return ptr;\n    } else if (allocStatus == ObjectCache::AllocStatus::kKeyAlreadyExists) {\n        ...\n    } else { // ObjectCache::AllocStatus::kAllocError\n        ...\n    }\n    ...\n}\n")),(0,a.mdx)("h3",{id:"get-objects"},"Get objects"),(0,a.mdx)("p",null,"To get objects from object-cache, call ",(0,a.mdx)("inlineCode",{parentName:"p"},"find")," or ",(0,a.mdx)("inlineCode",{parentName:"p"},"findToWrite")," API:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-cpp"},"// Look up an object in read-only access.\ntemplate <typename T>\nstd::shared_ptr<const T> find(folly::StringPiece key);\n\n// Look up an object in mutable access\ntemplate <typename T>\nstd::shared_ptr<T> findToWrite(folly::StringPiece key);\n")),(0,a.mdx)("p",null,"Example:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-cpp"},'std::shared_ptr<const Foo> foo = objcache->find<Foo>("foo");\nif (foo !== nullptr) {\n    ... some read operation\n}\n\nstd::shared_ptr<Foo> mutableFoo = objcache->findToWrite<Foo>("foo");\nif (mutableFoo !== nullptr) {\n    ... some write operation\n}\n\n')),(0,a.mdx)("h3",{id:"remove-objects"},"Remove objects"),(0,a.mdx)("p",null,"To remove objects from object-cache, call ",(0,a.mdx)("inlineCode",{parentName:"p"},"remove")," API:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-cpp"},"// Remove an object from cache by its key. No-op if object doesn't exist.\nvoid remove(folly::StringPiece key);\n")),(0,a.mdx)("p",null,"Example:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-cpp"},'// objcache is empty\nobjcache->remove<Foo>("foo"); // no-op\n\nobjcache->insertOrReplace<Foo>("foo", std::move(foo));\n...\n\nobjcache->remove<Foo>("foo"); // foo will be removed\n')))}u.isMDXComponent=!0}}]);
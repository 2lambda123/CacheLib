<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="CacheLib Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="CacheLib Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="CacheLib" href="/opensearch.xml"><title data-react-helmet="true">RAM cache indexing and eviction | CacheLib</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:image" content="https://cachelib.org/img/CacheLib-Logo-small.png"><meta data-react-helmet="true" name="twitter:image" content="https://cachelib.org/img/CacheLib-Logo-small.png"><meta data-react-helmet="true" property="og:url" content="https://cachelib.org/docs/Cache_Library_Architecture_Guide/ram_cache_indexing_and_eviction"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="RAM cache indexing and eviction | CacheLib"><meta data-react-helmet="true" name="description" content="This article takes a deep look at CacheLib&#x27;s RAM cache&#x27;s AccessContainer and"><meta data-react-helmet="true" property="og:description" content="This article takes a deep look at CacheLib&#x27;s RAM cache&#x27;s AccessContainer and"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://cachelib.org/docs/Cache_Library_Architecture_Guide/ram_cache_indexing_and_eviction"><link data-react-helmet="true" rel="alternate" href="https://cachelib.org/docs/Cache_Library_Architecture_Guide/ram_cache_indexing_and_eviction" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://cachelib.org/docs/Cache_Library_Architecture_Guide/ram_cache_indexing_and_eviction" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.135ed374.css">
<link rel="preload" href="/assets/js/runtime~main.5fc5a39a.js" as="script">
<link rel="preload" href="/assets/js/main.67772711.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script>
<div style="display: none; text-align: center; background-color: white; color: black;" id="internaldocs-banner"></div><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><div class="announcementBar_axC9" style="background-color:#20232a;color:#fff" role="banner"><div class="announcementBarContent_6uhP">Support Ukraine ðŸ‡ºðŸ‡¦ <a target="_blank" rel="noopener noreferrer" href="https://opensource.fb.com/support-ukraine"> Help Provide Humanitarian Aid to Ukraine</a>.</div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/CacheLib-Logo-small.png" alt="My Facebook Project Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/img/CacheLib-Logo-small.png" alt="My Facebook Project Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title">CacheLib</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/installation/">Build and Installation</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">API and Usage</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/Cache_Library_User_Guides/Cachebench_Overview">Cachebench</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/Cache_Library_Architecture_Guide/overview_a_random_walk">Architecture Guide</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/learnmore/">Learn More</a><a href="https://github.com/facebook/CacheLib" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_2i4l react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_NKBi"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button class="clean-btn backToTopButton_i9tI" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Architecture Guide</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Overview</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">RAM Cache</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Cache_Library_Architecture_Guide/ram_cache_indexing_and_eviction">RAM cache indexing and eviction</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Cache_Library_Architecture_Guide/slab_rebalancing">Slab Rebalancing - How Does It Work?</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Cache_Library_Architecture_Guide/compact_cache_design">Compact Cache Design</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Hybrid Cache</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_XoVD"><div class="docItemContainer_6jsP"><article><header><h1 class="docTitle_ft6A">RAM cache indexing and eviction</h1></header><div class="markdown"><p>This article takes a deep look at CacheLib&#x27;s RAM cache&#x27;s AccessContainer and
MMContainer, which powers the indexing and eviction of RAM cache.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="containers"></a><strong>Containers</strong><a class="hash-link" href="#containers" title="Direct link to heading">#</a></h2><p>The word &quot;container&quot; in the names of AccessContainer and MMContainer refers to
<a href="https://stackoverflow.com/questions/5004162/what-does-it-mean-for-a-data-structure-to-be-intrusive" target="_blank" rel="noopener noreferrer">intrusive containers</a>.
For the purpose of understanding this article, the gist here is that the
container does not store a copy of the element. So an item in CacheLib can be
retrieved by both AccessContainer and MMContainer without duplicating copies.
This is achieved by storing some metadata in the item itself. The details would
be discussed in the sections below.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="accesscontainer"></a><strong>AccessContainer</strong><a class="hash-link" href="#accesscontainer" title="Direct link to heading">#</a></h2><p>The AccessContainer is an intrusive hook based container and supports a
standard interface that works with CacheAllocator. It could be viewed as a
large hash table that serves as the index of the entire CacheLib cache. An
item&#x27;s accessibility is controlled only by the access container. So an item is
accessible (can be returned by find request) only after it is inserted into the
access container and is no longer accessible once it is removed from the access
container. There is only one access container for the entire CacheLib cache
(see <code>accessContainer_</code> in <code>cachelib/allocator/CacheAllocator.h</code>).</p><p>It has the following major API functions:</p><ul><li>find: Given a string key, return the item handle. This is used when the client calls find on a key.<ul><li>Example call-site: <code>CacheAllocator::findInternal</code>.</li></ul></li><li>insert: Insert an item handle into the AccessContainer, making it accessible
to future find requests. This is used when the client calls the
CacheAllocator&#x27;s inset API.<ul><li>Example call-site: <code>CacheAllocator::insertImpl</code>.</li></ul></li><li>remove: Remove an item from the AccessContainer, making it not accessible to
future find requests. This is used when the client removes an item from the
cache. This is also used when moving an item (more details on
<a href="/docs/Cache_Library_Architecture_Guide/slab_rebalancing">4. How do we handle chained items</a>).<ul><li>Example call-site: <code>CacheAllocator::removeImpl</code>.</li></ul></li></ul><p>The full API can be found in <code>ChainedHashTable::Container</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="chainedhashtable"></a><strong>CHAINEDHASHTABLE</strong><a class="hash-link" href="#chainedhashtable" title="Direct link to heading">#</a></h3><p>This is our only implementation of access container.</p><p>The memory payload is a hash table (<em>ChainedHashTable::Container::ht_</em>), which
contains a list of compressed pointers (<code>ChainedHashTable::Impl::hashTable_</code>).
Each compressed pointer in this list (together with the compressor) points to
the head node of each bucket&#x27;s chain. In CacheLib cache, this node (the <code>type T</code> in
in type parameter for ChainedHashTable::Impl) is a CacheItem
(<code>allocator/CacheItem.h</code>). For CacheItem to be eligible as a node here, it needs
to meet the following criterium:</p><ul><li><p>Carries the hook (<code>accessHook_</code> in <code>cachelib/allocator/CacheItem.h</code>): This
hook is defined as <code>struct CACHELIB_PACKED_ATTR Hook</code> in
<code>cachelib/allocator/ChainedHashTable.h</code>, which points to the next item in the
bucket&#x27;s chain. This adds a compressed pointer to CacheItem&#x27;s payload.</p></li><li><p>Implements <code>isAccessible()</code>, <code>markAccessible()</code>, <code>unmarkAccessible()</code>. This
is backed by one bit in the CacheItem&#x27;s flags.</p></li><li><p>Implements <code>getKey()</code>. This doesn&#x27;t require extra memory, as the CacheItem
already store the key for other purpose.</p></li></ul><p>With the intrusive implementation, operations on this hash table is easy:</p><ul><li><p><code>find()</code>: Hash the key and get the bucket then iterate over the bucket chain
(<code>Handle find(Key key)</code> function in <code>cachelib/allocator/ChainedHashTable.h</code>).</p></li><li><p><code>insert()</code>: Find the bucket and replace the head with the node to be inserted
(<code>bool ChainedHashTable::Container&lt;...::insert(T&amp; node)</code> in <code>cachelib/allocator/ChainedHashTable-inl.h</code>).</p></li><li><p><code>remove()</code>: Find the bucket and remove the node from the chain
(<code>bool ChainedHashTable::Container&lt;T, HookPtr, LockT&gt;::remove(T&amp; node)</code> in <code>cachelib/allocator/ChainedHashTable-inl.h</code>).</p></li></ul><p>Find and remove requires iteration on the bucket chain but insert does not.
Note that remove requires the iteration on the chain not to locate the node
itself (as we have it from the API) but to find the previous item so that the
node can be removed from the linked list.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="mmcontainer"></a><strong>MMContainer</strong><a class="hash-link" href="#mmcontainer" title="Direct link to heading">#</a></h2><p>RAM evictions are controlled by MMContainers. It can be viewed as an eviction
algorithm powered by intrusive containers. When an item is inserted, it is
added into the MMContainer (e.g. entering the eviction queue). When an item is
accessed, it is recorded (e.g. promoted in LRU). When the cache allocator asks
for an item to evict, it returns an iterator for the next item to be evicted.
When the item is finally removed form the queue, it removes the item form the
queue. There is one MMContainer <strong>per allocation class in each
pool</strong> (see <code>evictableMMContainers_</code> in <code>cachelib/allocator/CacheAllocator.h</code>).</p><p>It has the following major API functions:</p><ul><li><code>insert</code>: Add an item into the eviction queue. This is called when an item is
inserted into the cache. This can also happen when we are moving an item and we
need to remove it from one MMContainer and add to another
(<code>CacheAllocator&lt;CacheTrait&gt;::insertInMMContainer(Item&amp; item)</code> in
<code>cachelib/allocator/CacheAllocator-inl.h</code>).</li><li><code>record</code>: Record an access of the item. Typically this means promoting the
item in some form of LRU queue (<code>void
  CacheAllocator&lt;CacheTrait&gt;::recordAccessInMMContainer(Item&amp; item, AccessMode
  mode)</code> in <code>cachelib/allocator/CacheAllocator-inl.h</code>).</li><li><code>remove</code>: Remove an item from the eviction queue. This is called when an item
is removed form the cache (evicted or explicitly removed by the client) (<code>bool
  CacheAllocator&lt;CacheTrait&gt;::removeFromMMContainer(Item&amp; item)</code> in
<code>cachelib/allocator/CacheAllocator-inl.h</code>).</li><li><code>getEvictionIterator</code>: Return an iterator of items to be evicted. This is
called when the cache allocator is looking for eviction. Usually the first item
that can be evicted (no active handles, not moving, etc) is used (see
<code>CacheAllocator&lt;CacheTrait&gt;::findEviction(PoolId pid, ClassId cid)</code> in
<code>cachelib/allocator/CacheAllocator-inl.h</code>).</li></ul><p>The full API can be found in <code>struct Container</code> in
<code>cachelib/allocator/MMLru.h</code>.  This links to MMLru, which is one of the
multiple MMContainers we implemented. All the operations above have constant
time complexity in each of the implementations.</p><p>The eviction requires an iterator instead of a single item because it is
possible that the item best for eviction is being referred to, moved, or for
some other reason can not be evicted. In this case, CacheAllocator advances the
iterator until a good victim is found or fails the eviction after too many
retries and further results in an allocation failrue.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="dlist"></a><strong>DLIST</strong><a class="hash-link" href="#dlist" title="Direct link to heading">#</a></h3><p>The multiple implementations of MMContainer all relies on the same intrusive
doubly-linked list implementation (<code>class DList</code> in <code>cachelib/allocator/datastruct/DList.h</code>).
The <em>hook</em> required by this is straightforward: just compressed pointers to the
next and previous item (<code>struct DListHook</code> in
<code>cachelib/allocator/datastruct/DList.h</code>).</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="lru"></a><strong>LRU</strong><a class="hash-link" href="#lru" title="Direct link to heading">#</a></h3><p>[MMLru](<code>class MMLru</code> in <code>cachelib/allocator/MMLru.h</code>) powers the LRU (see <a href="/docs/Cache_Library_User_Guides/eviction_policy/">lru</a>).</p><p>It is powered by a single DList, which holds the head and tail of the queue. It
also has a reference to <em>the insertion
point</em> (see <code> T* insertionPoint_{nullptr};</code> in <code>cachelib/allocator/MMLru.h</code>)
where new items are inserted. The operations are straightforward standard
linked list operation that takes constant time:</p><ul><li>Insert: A new item is inserted to the insertion point.</li><li>Record: A promoted item is moved to the head of the queue.</li><li>Remove: The item is removed from the queue.</li><li>Eviction iterator: An iterator pointing to the tail of the queue is returned and moves backward.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="lru-2q"></a><strong>LRU-2Q</strong><a class="hash-link" href="#lru-2q" title="Direct link to heading">#</a></h3><p>MM2Q powers <a href="/docs/Cache_Library_User_Guides/eviction_policy/#lru-2q">LRU2Q</a>.
It is powered by <code>MultiDList</code> (variable <code>LruList</code> in <code>struct Container</code> in <code>cachelib/allocator/MM2Q.h</code>).
Underneath, it contains 5 DLists: Hot, Warm, WarmTail, Cold, ColdTail.</p><ul><li>Insert: A new item is inserted to the head of the Hot queue.</li><li>Record:<ul><li>An item in Hot list is moved to the head of the Hot queue.</li><li>An item in Warm or WarmTail list is moved to the head of the Warm queue.</li><li>An item in Cold or ColdTail list is moved to the head of the Warm queue.</li></ul></li><li>Remove: The item is removed from the current queue.</li><li>Eviction iterator: An iterator goes from the tail of ColdTail backwards, then to Cold, WarmTail, Warm, Hot.</li></ul><p>The Tail lists are optional queues designed to supply statistics on access
counts on the last 1 slab worths of items on the Cold and Warm queue. This
stats can help us understand if assigning one more slab to this particular
allocation class would be a good tradeoff. The marginal hits policy of
rebalancing relies on this statistics (more details in <a href="/docs/Cache_Library_Architecture_Guide/slab_rebalancing">2. How do we pick a slab</a>).</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="tiny-lfu"></a><strong>TINY-LFU</strong><a class="hash-link" href="#tiny-lfu" title="Direct link to heading">#</a></h3><p><code>class MMTinyLFU</code> (in <code>cachelib/allocator/MMTinyLFU.h</code>) powers
<a href="/docs/Cache_Library_User_Guides/eviction_policy/#tinylfu">Tiny-LFU</a>. This is an
implementation of W-TinyLFU cache eviction policy described in
[https://arxiv.org/pdf/1512.00727.pdf].
The main cache and the tiny cache. The tiny cache is typically sized to be 1%
of the total cache with the main cache being the rest 99%. Both caches are
implemented using LRUs. New items land in tiny cache. During eviction, the tail
item from the tiny cache is promoted to main cache if its frequency is higher
than the tail item of of main cache, and the tail of main cache is evicted.
This gives the frequency based admission into main cache. Hits in each cache
simply move the item to the head of each LRU cache.</p><p>The frequency is maintained by <strong>count-min-sketch</strong> (<code>cachelib/common/CountMinSketch.h</code>)</p><ul><li>Insert: A new item is added into the Tiny queue<ul><li>If the Tiny queue&#x27;s size is larger than expected, promote the tail of the
Tiny queue into Main queue. Otherwise, swap the tails of the queues, if the
Tiny queue&#x27;s tail is more frequently accessed than the Main tail.</li><li>If the count-min-sketch is too small for the number of items in the queue, recreate the counters with doubled capacity.<ul><li>Note: if recreation happens, the existing frequency counts will be erased.</li></ul></li></ul></li><li>Record: A promoted item is move to the head of the current queue.</li><li>Remove: The item is removed from the queue.</li><li>Eviction iterator: The iterator consists of two sub-iterators pointing
towards the tails of Tiny and Main. The overall iterator returns the less
frequently used item of the current two sub-iterators.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="common-configurations"></a><strong>COMMON CONFIGURATIONS</strong><a class="hash-link" href="#common-configurations" title="Direct link to heading">#</a></h3><p>There are a few common set ups shared by all these three implementations.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="thread-safety"></a><strong>THREAD SAFETY</strong><a class="hash-link" href="#thread-safety" title="Direct link to heading">#</a></h4><p>All of the operations are protected by a mutex.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="optional-promotion"></a><strong>OPTIONAL PROMOTION</strong><a class="hash-link" href="#optional-promotion" title="Direct link to heading">#</a></h4><p>Configs on whether to update on a read and/or write can be specified. For
example if updateOnRead is set to false, no operation would be taken if the
item is read.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="lru-refresh-time"></a><strong>LRU REFRESH TIME</strong><a class="hash-link" href="#lru-refresh-time" title="Direct link to heading">#</a></h4><p>LRU refresh time is an interval within which consecutive record access won&#x27;t
re-promote the item. The intention for this mechanism is to reduce lock
contention. LRU refresh time is calculated on the oldest element&#x27;s age
multiplied by lruRefreshRatio set in config and capped by a max time (currently
900 seconds). It is recalculated once every time interval as specified in the
config (mmReconfigureIntervalSecs). The different MMContainers do have slightly
different implementations:</p><ul><li>In MMLru, items accessed for the first time are not constrained by LRU
refresh time and will be promoted for sure. It uses the time difference between
current time and the tail item&#x27;s last update time as the oldest element age.  *
In MMTiny-LFU, items accessed for the first time are not constrained by LRU
refresh time and will be promoted for sure. It uses the time difference between
current time and the tail of main queue&#x27;s last update time as the oldest
element age.</li><li>In MM2Q, the time difference between current time and the tail of wamr queue
is used as the oldest element age.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="eviction-age-statistics"></a><strong>EVICTION AGE STATISTICS</strong><a class="hash-link" href="#eviction-age-statistics" title="Direct link to heading">#</a></h4><p><strong>EvictionAgeStat</strong> (<code>struct EvictionAgeStat</code> in
<code>cachelib/allocator/CacheStats.h</code>) can be retrieved from all of the
implementations. The projectedAge is calculated when the caller calls eviction
stat with a projectedLength &gt; 0. It is the time difference between current and
the last updated time of the projectedLength&#x27;th item from the tail of the major
queue.</p><ul><li>For MMLru, there is only one queue and its statistics is populated into
warmQueueStat while the other two queue stats are left 0.</li><li>For MM2Q, all the stats are populated. The major queue that is used for
projection is the warm queue.</li><li>For MMTiny-LFU, only the main queue&#x27;s stats is populated into warmQueueStat.
And the main queue is used for projection.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="summary"></a><strong>Summary</strong><a class="hash-link" href="#summary" title="Direct link to heading">#</a></h2><p>In this article we went over the indexing (Access Container) and eviction (MM
Container) mechanism of CacheLib. They are implemented by intrusive hooks in
the CacheItem. For public API in CacheAllocator, AccessContainer and
MMContainer works together to perform indexing and eviction management
efficiently.</p><p>Usually, when the API takes a key from the client, <code>AccessContainer::find</code> is
used to locate the CacheItem. Then the MMContainer can be identified from the
item and operation can be performed in constant time.  The most time overhead
on common cache operations (find, insert, remove) is two iterations on the hash
table&#x27;s chain, which is still quite efficient (happens on remove).</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/facebook/docusaurus/edit/master/website/docs/Cache_Library_Architecture_Guide/RAM_cache_indexing_and_eviction.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/Cache_Library_Architecture_Guide/common_components"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Cachelib Common Components</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Cache_Library_Architecture_Guide/slab_rebalancing"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Slab Rebalancing - How Does It Work? Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#containers" class="table-of-contents__link"><strong>Containers</strong></a></li><li><a href="#accesscontainer" class="table-of-contents__link"><strong>AccessContainer</strong></a><ul><li><a href="#chainedhashtable" class="table-of-contents__link"><strong>CHAINEDHASHTABLE</strong></a></li></ul></li><li><a href="#mmcontainer" class="table-of-contents__link"><strong>MMContainer</strong></a><ul><li><a href="#dlist" class="table-of-contents__link"><strong>DLIST</strong></a></li><li><a href="#lru" class="table-of-contents__link"><strong>LRU</strong></a></li><li><a href="#lru-2q" class="table-of-contents__link"><strong>LRU-2Q</strong></a></li><li><a href="#tiny-lfu" class="table-of-contents__link"><strong>TINY-LFU</strong></a></li><li><a href="#common-configurations" class="table-of-contents__link"><strong>COMMON CONFIGURATIONS</strong></a></li></ul></li><li><a href="#summary" class="table-of-contents__link"><strong>Summary</strong></a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Reach Us</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/facebook/CacheLib" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.facebook.com/cachelib/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Facebook Developer Page<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/MetaOpenSource" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Legal</div><ul class="footer__items"><li class="footer__item"><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Privacy<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Terms<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a href="https://opensource.facebook.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_SRtH"><img src="/img/oss_logo.png" alt="Facebook Open Source Logo" class="themedImage_TMUO themedImage--light_4Vu1 footer__logo"><img src="/img/oss_logo.png" alt="Facebook Open Source Logo" class="themedImage_TMUO themedImage--dark_uzRr footer__logo"></a></div><div class="footer__copyright">Copyright Â© 2022 Meta Platforms, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5fc5a39a.js"></script>
<script src="/assets/js/main.67772711.js"></script>
</body>
</html>